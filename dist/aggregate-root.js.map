{"version":3,"file":"aggregate-root.js","sourceRoot":"","sources":["../src/aggregate-root.ts"],"names":[],"mappings":"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","sourcesContent":["import { DomainEvent } from \"./domain-event\";\nimport { AggregateState } from \"./aggregate-state\";\nimport { given } from \"@nivinjoseph/n-defensive\";\nimport { ApplicationException } from \"@nivinjoseph/n-exception\";\nimport { AggregateRootData } from \"./aggregate-root-data\";\nimport \"@nivinjoseph/n-ext\";\n\n// public\nexport abstract class AggregateRoot<T extends AggregateState>\n{\n    private readonly _state: T;\n    private readonly _retroEvents: ReadonlyArray<DomainEvent<T>>;\n    private readonly _retroVersion: number;\n    private readonly _currentEvents = new Array<DomainEvent<T>>(); // track unit of work stuff\n\n\n    public get id(): string { return this._state.id; }\n    \n    public get retroEvents(): ReadonlyArray<DomainEvent<T>> { return this._retroEvents.orderBy(t => t.version); }\n    public get retroVersion(): number { return this._retroVersion; } \n    \n    public get currentEvents(): ReadonlyArray<DomainEvent<T>> { return this._currentEvents.orderBy(t => t.version); }\n    public get currentVersion(): number { return this._state.version; }\n    \n    public get events(): ReadonlyArray<DomainEvent<T>> { return [...this._retroEvents, ...this._currentEvents].orderBy(t => t.version); }\n    public get version(): number { return this.currentVersion; }\n\n    public abstract get createdAt(): number;\n    public get updatedAt(): number { return this.events.orderByDesc(t => t.version)[0].occurredAt; }\n\n    public get hasChanges(): boolean { return this.currentVersion !== this.retroVersion; }\n\n\n    protected get state(): T { return this._state; }\n\n\n    public constructor(events: ReadonlyArray<DomainEvent<AggregateState>>, initialState?: T | object)\n    {\n        given(events, \"events\").ensureHasValue().ensureIsArray().ensure(t => t.length > 0);\n        given(initialState, \"initialState\").ensureIsObject();\n\n        this._state = initialState || {} as any;\n\n        this._retroEvents = events;\n        this._retroEvents.orderBy(t => t.version).forEach(t => t.apply(this._state));\n        this._retroVersion = this.currentVersion;\n    }\n\n    public static deserialize(aggregateType: Function, eventTypes: ReadonlyArray<Function>, data: AggregateRootData): AggregateRoot<AggregateState>\n    {\n        given(aggregateType, \"aggregateType\").ensureHasValue().ensureIsFunction();\n        given(eventTypes, \"eventTypes\").ensureHasValue().ensureIsArray()\n            .ensure(t => t.length > 0, \"no eventTypes provided\")\n            .ensure(t => t.map(u => (<Object>u).getTypeName()).distinct().length === t.length, \"duplicate event types detected\");\n        given(data, \"data\").ensureHasValue().ensureIsObject()\n            .ensureHasStructure({\n                $id: \"string\",\n                $version: \"number\",\n                $createdAt: \"number\",\n                $updatedAt: \"number\",\n                $events: [{\n                    $name: \"string\",\n                    $occurredAt: \"number\",\n                    $version: \"number\"\n                }]\n            });\n        \n        const events = data.$events.map((eventData: any) =>\n        {\n            const name = eventData.$name;\n            const event = eventTypes.find(t => (<Object>t).getTypeName() === name);\n            if (!event)\n                throw new ApplicationException(`No event type supplied for event with name '${name}'`);\n            if (!(<any>event).deserializeEvent)\n                throw new ApplicationException(`Event type '${name}' does not have a static deserializeEvent method defined.`);\n            return (<any>event).deserializeEvent(eventData);\n        });\n\n        return new (<any>aggregateType)(events);\n    }\n\n\n    public serialize(): AggregateRootData\n    {\n        return {\n            $id: this.id,\n            $version: this.version,\n            $createdAt: this.createdAt,\n            $updatedAt: this.updatedAt,\n            $events: this.events.map(t => t.serialize())\n        };\n    }\n\n\n    protected applyEvent(event: DomainEvent<AggregateState>): void\n    {\n        event.apply(this._state);\n\n        this._currentEvents.push(event);\n    }\n}"]}